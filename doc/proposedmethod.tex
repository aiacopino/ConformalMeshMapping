\section{Proposed Method}
\subsection{Choice/ Justification}
criteria:
- Accuracy for domains with sharp corners or high curvature
- Speed for practical mesh sizes
- Robustness - does it fail for certain domain shapes?
- Implementation complexity given your timeline
- Jacobian computation - analytical vs numerical differentiation
\subsection{Implementation}
- Separate modules for boundary parameterization, mapping computation, Jacobian eval, and mesh transformation
- plot original vs. mapped grids (e.g., Matplotlib quiver for Jacobians) to spot issues early.
\subsection{Numerical Experiments/ Testing}
check angle preservation (e.g., via dot products on mapped vectors) and scale factors ($det(D\Phi) > 0$, $|\frac{\del\Phi}{\del z}|$ constant in theory).
- Test suite: Use known exact mappings (e.g., disk to square via Schwarz-Christoffel) for error metrics (L2 norm on boundary points).
- Metrics: Runtime for N points, mesh quality post-mapping (e.g., min/max angles in triangles, shape regularity ratio).
- Real-world applicability: Apply to a sample FEM problem (e.g., Poisson equation on $\Omega$) and compare accuracy/speed vs. uniform mesh.
- Robustness: Vary boundary complexity (smooth vs. corners), noise in Fourier coeffs, mesh resolutions.
- Debugging: Use assertions for bijectivity (e.g., check injectivity numerically)
- Error handling - what happens with degenerate inputs?
\subsection{Results}
